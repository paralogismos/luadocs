#! /usr/bin/env sh
# configure
# Configuration script for `luadocs`.
set -e
#set -x

# Global build parameters
exec_name="luadocs"
status="./configure"

usage() {
    printf "configure script for %s\n" $exec_name
    printf "\n"
    printf "%s\n" "USAGE:"
    printf "\t%s\n" "configure [OPTION] ..."
    printf "%s\n" ""
    printf "%s\n" "OPTIONS:"
    printf "\t%s\n" "--exec_prefix  ... Set executable directories prefix"
    printf "\t%s\n" "                   Default is \`/usr/local\`"
    printf "%s\n" ""
    printf "\t%s\n" "--bindir       ... Set user executable directory"
    printf "\t%s\n" "                   Default is \`<exec_prefix>/bin\`"
    printf "%s\n" ""
    printf "\t%s\n" "-h | --help  ... Show this help screen"
}

script_fail() {
    printf "*** %s : %s ***\n" "$1" "$2" >&2
    cd "$reset_dir"
    exit 2
}

# Performs initial tilde expansion on a path string.
tilde_expand() {
    expanded=
    no_tilde=${1#"~/"}
    if [ "$no_tilde" = "$1" ] ; then       # possible logname expansion
        no_tilde=${1#"~"}
        if [ "$no_tilde" =  "$1" ] ; then  # no tilde expansion to perform
            expanded="$no_tilde"
        elif [ -z "$no_tilde" ] ; then     # simple $HOME expansion
            expanded="$HOME"
        else                               # possible logname expansion
            logname=${no_tilde%%/*}
            logpath=${no_tilde#*/}
            if [ "$logpath" = "$no_tilde" ] ; then logpath='' ; fi  # no path after logname
            # Linux only:
            expanded=$(cat /etc/passwd | grep "$logname" | cut -d: -f6)
            # Fall back to unexpanded path if logname is not found.
            # Otherwise, if there is a logpath add it to the expanded logname.
            if [ -z "$expanded" ] ; then expanded="$1"
            elif ! [ -z "$logpath" ] ; then expanded="$expanded/$logpath"
            fi
        fi
    else  # Just a simple $HOME expansion.
        expanded="$HOME/$no_tilde"
    fi
    # Remove trailing slashes before printing results.
    printf '%s' "${expanded%/}"
}

# Verify dependencies.

# Parse script options.
exec_prefix=/usr/local  # executable directories prefix
bindir=                 # user executable directory

# Check long options for required arguments.
require_arg() {
    if [ -z "$OPTARG" ] ; then
        script_fail "Argument required" "--$OPT"
    fi
}

while getopts h-: OPT
do
    if [ $OPT = "-" ]  ; then
        OPT=${OPTARG%%=*}      # get long option
        OPTARG=${OPTARG#$OPT}  # get long option argument
        OPTARG=${OPTARG#=}
    fi
    case "$OPT" in
        exec_prefix )
            require_arg
            exec_prefix=$(tilde_expand "$OPTARG")
            status="${status} --exec_prefix=${exec_prefix}"
            ;;
        bindir )
            require_arg
            bindir=$(tilde_expand "$OPTARG")
            status="${status} --bindir=${bindir}"
            ;;
        h | help )
            usage
            exit 0 ;;
        \?)
            usage
            exit 2 ;;  # short option fail reported by `getopts`
        *)
            script_fail "Unrecognized option" "--$OPT" ;;  # long option fail
    esac
done

# Set dependent options if not set by user
if [ -z "$bindir" ] ; then
    bindir="$exec_prefix"/bin  # user executable directory
fi

# Create Makefile from template.
sed "1c # This Makefile was generated automatically by \`configure\`.
/^@bindir/c bindir=${bindir}" Makefile.in > Makefile

# Create `config.status` file.
echo "${status}" > config.status
